### 1. Lecture 8启发

- 字符串子串获取：C++不能向Python那样使用`[:]`获取子串，但string类有成员函数`str.substr(3, 2)`可以获取子串

### 2. 作业启发

- C++字符串和数字相互转换
  - 数字转string字符串：`to_string()`
  - 数字转c字符串：`itoa(num, 字符数组首字母指针, 进制)`
  - string字符串转数字：`stoi()`
  - c字符串转数字：`atoi()`
  
- `transform(word.begin(), word.end(), word.begin(), ::tolower);`不加::会报错

- 当遇到==需要输入的字符串满足一定条件，否则停止程序运行==的情况：把输入放到while循环的条件中去，满足条件返回true否则返回false

  ```C++
  while (promptWords(startWord, endWord))
  {
      findWordLadder(startWord, endWord, dictionary);
  }
  
  cout << "Have a nice day!" << endl;
  
  return 0;
  ```

- C++中一个if可以接很多个else if和一个else

- 实现只要运行失败，就重新尝试：可以将失败条件写入while条件中（退出的条件只能是成功）

  ```C++
  while (!fail())
  {
      
  }
  ```

  运行直到输入0，可以将输入0的部分放入while条件中（退出的条件只能是输入0）

  ```C++
  while (getLenth(wordsLength)) 
  {  
      
  }
  ```

### 3. Section 2启发

- Q5：反转不需要每次头尾同时去掉一个元素！选择一边一次去掉一个即可！

- Q6：递归中，如果某次递归需要调用自身两次，可以把第一调用的结果存下来，避免再次计算的开销！

  ```C++
  // good version
  string starString(int n)
  {
      if (n < 0)
          throw "Invalid input.";
      else if (n == 0)
          return "*";
      else
      {
          string star = starString(n - 1);
          return star + star;
      }
  }
  // bad version
  string starString(int n)
  {
      if (n < 0)
          throw "Invalid input.";
      else if (n == 0)
          return "*";
      else
      {
          return starString(n - 1) + starString(n - 1);
      }
  }
  ```

  分析调用次数可以发现，第一个版本调用次数是随n线性变化的，而第二个版本是指数变化

- Q10：非常非常好的题

  左值和右值引用：在C++中，不能直接使用非const左值引用绑定到右值，主要是为了避免潜在的问题，其中一个主要问题是悬空引用（dangling reference）

  考虑以下情况：

  ```C++
  int& ref = 10;  // 错误！不能将非const左值引用绑定到右值
  ```

  如果这样的绑定是允许的，那么 `ref` 将引用一个临时的右值 `10`。当这个右值超出其生命周期时，`ref` 就变成了悬空引用，指向了一个不再存在的内存位置。这会导致未定义行为和程序崩溃

  为了解决这个问题，C++引入了对右值的引用，即右值引用。右值引用使用 `&&` 进行声明，例如：

  ```C++
  int&& rref = 10;  // 右值引用绑定到右值
  ```

  右值引用允许我们更灵活地处理右值，同时通过移动语义提高效率。通过使用右值引用，我们可以明确表示对临时对象的引用，并能够进行有效的资源管理和性能优化