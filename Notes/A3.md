### 1. 作业启发

- 写递归时，如果发现需要某一个参数，但接口里并没有提供，则应该想到使用helper function实现额外的参数传递、信息记录！
- 在C++中要小心整数除法！表面上看，当角度`int theta = 90;`，`cos(theta / 180 * pi)`等于0，而实际上由于是整数除法，90/180直接得到0，cos出来值等于1！！！Python中则不是这样

### 2. Section 3启发

- Q2：考虑从小硬币到大硬币和从大硬币到小硬币两种思路：
  - 前者：CS106B
  - 后者：CS61A
- Q7：关于遍历容器过程中同时修改容器元素的问题
  - 在C++的标准库中，对于大多数容器，当你使用自增迭代器（`++`操作符）时，如果在迭代过程中删除了元素，这可能导致迭代器失效或跳过下一个元素。例如，在`std::vector`中删除元素会导致迭代器失效，因为`std::vector`使用连续的内存存储元素，删除一个元素会影响后续元素的位置。而在`std::set`这样的关联容器中，由于它是基于红黑树实现的，删除一个元素不会影响其他元素的位置，因此迭代器仍然有效
  - 但是，为了确保稳定的迭代，推荐在删除元素后使用`erase`返回的迭代器，而不是简单地使用自增操作。这样可以确保迭代器指向正确的位置，避免跳过下一个元素或导致迭代器失效的问题。在你的代码中，使用`iter = domes.erase(iter);`来更新迭代器是一个好的实践
  - 经检验，还是==不要在遍历某数据结构的时候改变它，而是应该创建一个数据副本==！！！发现即使如上第二条所述，set也会出现未定义行为报错，搞不懂为什么！！！
  - 对迭代器指向元素取地址：先&再*`&*iter`