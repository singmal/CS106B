### 1. Section 4启发

- Q7：好题！字符串匹配类型的题都用这种思路！
- Q8：有趣，Counting Sort，以空间换时间，O(n+k)的排序时间复杂度！
  - 将n个范围0-k的无序元素放入大小为k的内存空间中：O(n)
  - 遍历k个内存空间：O(k)，查看每一块上数的大小
  - 数不为0的话放入数组中，一共放n次，O(n)
  - 综上，排序时间复杂度为O(n+k)


### 2. Assignment 04启发

- 如果类中有引用类型的成员，由于引用必须在被创建的同时进行初始化，一定要对它使用成员初始化列表！！！

- 如果类中只有一个函数用到某变量，该变量应该作为函数中定义的局部变量而不是类成员变量

- 应该尽可能将参数和函数声明为const

- 注意if-else代码块中定义的变量在if-else块外面就用不了了！不是一个名称空间！因此如果遇到下面的情况：

  ```C++
  class Boggle
  {
      public:
          Boggle(Lexicon& dictionary, string boardText = "");
          ...
      private:
          Grid<char> board;
          Lexicon& dict;
  };
  
  // dict作为引用成员，必须在类内初始化列表进行初始化
  Boggle::Boggle(Lexicon& dictionary, string boardText) : dict(dictionary)
  {
  	...
  }
  
  // 而主程序中要分情况调用构造函数
  if (ch == 'Y')
      Boggle board = Boggle(dictionary);
  else
  {
      bool run = true;
      string textOnBoard;
      while (run)
      {
          cout << "Type the 16 letters to appear on the board: ";
          getline(cin, textOnBoard);
          int size = textOnBoard.size();
          run = false;
          if (size != 16)
          {
              run = true;
          }
          for (int i = 0; i < size && !run; i++)
          {
              if (!isalpha(textOnBoard[i]))
              {
                  run = true;
                  break;
              }
          }
          if (run)
          {
              cout << "That is not a valid 16-letter board string. Try again." << endl;
          }
      }
      Boggle board = Boggle(dictionary, textOnBoard);
  }
  ```

  此时会很尴尬的发现，`board`白定义了，在外面用不了！而由于有引用成员，只能在一开始定义的时候就传好引用参数，无法把`board`声明拿到if的前面！

  解决方法：用指针动态控制内存

  ```C++
  Boggle* boardPtr;
  
  if (ch == 'Y')
      boardPtr = new Boggle(dictionary);
  else
  {
      bool run = true;
      string textOnBoard;
      while (run)
      {
          cout << "Type the 16 letters to appear on the board: ";
          getline(cin, textOnBoard);
          int size = textOnBoard.size();
          run = false;
          if (size != 16)
          {
              run = true;
          }
          for (int i = 0; i < size && !run; i++)
          {
              if (!isalpha(textOnBoard[i]))
              {
                  run = true;
                  break;
              }
          }
          if (run)
          {
              cout << "That is not a valid 16-letter board string. Try again." << endl;
          }
      }
      boardPtr = new Boggle(dictionary, textOnBoard);
  }
  ```

- 自定义类中包含STL容器作为成员，该如何初始化：

  ```C++
  // 1. 在类的声明处直接初始化
  #include <iostream>
  #include <vector>
  
  class MyClass
  {
      private:
          std::vector<int> myVector = {1, 2, 3, 4, 5}; // 直接在类的声明处初始化myVector
      ...
  }
  
  // 2. 在成员初始化列表中初始化
  #include <iostream>
  #include <vector>
  
  class MyClass
  {
      private:
          std::vector<int> myVector; // 类成员，类型为vector<int>
  
      public:
          // 构造函数，使用成员初始化列表初始化myVector
          MyClass() : myVector({1, 2, 3, 4, 5}) {} // 初始化myVector为包含一些元素的向量
          ...
  }
  
  // 3. 在类的构造函数中初始化
  #include <iostream>
  #include <vector>
  
  class MyClass
  {
      private:
          std::vector<int> myVector; // 类成员，类型为vector<int>
  
      public:
          // 构造函数中初始化myVector
          MyClass()
          {
          	myVector = {1, 2, 3, 4, 5}; // 使用赋值语句在构造函数中初始化myVector
      	}
  }
  ```

- 在条件语句中，注意利用与/或逻辑运算符的执行顺序，避免数组越界、除0等情况的发生。比如：

  ```C++
  if (!mark.inBounds(i, j) || mark[i][j] == 'x')
          return;
  ```

  先判断mark\[i\]\[j\]是否越界，然后才判断是否为x！如果反过来写，就很可能发生越界错误！